<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chat peer-to-peer crypt√© avec PeerJS">
    <meta name="theme-color" content="#2c3e50">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="P2P Chat">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="icon.png">
    <title>Canal priv√© chiffr√© chat voix P2P - PeerJS</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 14px;
        }

        .header-version {
            opacity: 0.9;
        }

        .header-id {
            font-size: 16px;
            color: #4CAF50;
            display: none;
        }

        .header-id strong {
            font-weight: 700;
        }

        .status {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background: #ffc107;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #28a745;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .connection-panel {
            padding: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group.inline {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group.inline label {
            flex-shrink: 0;
            margin-bottom: 0;
        }

        .input-group.inline input {
            flex: 1;
            max-width: 200px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #495057;
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3a3a3a 0%, #2c3e50 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-inline {
            width: auto;
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
            margin-left: 8px;
        }

        .id-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-container {
            display: none;
            flex-direction: column;
            height: 500px;
        }

        .chat-container.active {
            display: flex;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }

        .message.sent {
            justify-content: flex-end;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .message.received .message-content {
            background: white;
            border: 1px solid #dee2e6;
            border-bottom-left-radius: 4px;
        }

        .message.sent .message-content {
            background: linear-gradient(135deg, #4a4a4a 0%, #2c3e50 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 4px;
        }

        .input-container {
            padding: 15px;
            background: white;
            border-top: 1px solid #dee2e6;
            display: flex;
            gap: 10px;
        }

        .input-container input {
            flex: 1;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            font-size: 16px;
        }

        .input-container input:focus {
            outline: none;
            border-color: #495057;
        }

        .input-container button {
            padding: 12px 20px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2c3e50 100%);
            color: white;
            border: none;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .input-container button:hover {
            transform: scale(1.05);
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 14px;
        }

        .encryption-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .disconnect-badge {
            display: inline-block;
            background: #dc3545;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }

        .disconnect-badge:hover {
            background: #c82333;
        }

        .hidden {
            display: none !important;
        }

        .invalid-input {
            color: #dc3545 !important;
        }

        .voice-controls {
            padding: 15px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            display: none;
            gap: 10px;
        }

        .voice-controls.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .btn-voice {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-voice.start {
            background: #28a745;
            color: white;
        }

        .btn-voice.start:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-voice.end {
            background: #dc3545;
            color: white;
        }

        .btn-voice.end:hover {
            background: #c82333;
        }

        .btn-voice.mute {
            background: #ffc107;
            color: #333;
        }

        .btn-voice.mute:hover {
            background: #e0a800;
        }

        .btn-voice.mute.active {
            background: #6c757d;
            color: white;
        }

        .voice-status {
            display: none;
            padding: 10px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            color: #155724;
            font-weight: 600;
            text-align: center;
            margin: 10px 15px;
            animation: pulse-green 2s infinite;
        }

        .voice-status.active {
            display: block;
        }

        @keyframes pulse-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Canal priv√© chiffr√© <span style="font-size: 0.4em;">v0.50</span></h1>
            <div class="header-info">
                <span class="header-id" id="headerId"></span>
            </div>
        </div>

        <div class="status">
            <div class="status-indicator" id="statusIndicator"></div>
            <div>
                <strong id="statusText">D√©connect√©</strong>
                <span class="encryption-badge" id="encryptionBadge" style="display: none;">üîí ECDH P-384</span>
                <button class="disconnect-badge" id="disconnectBadge" style="display: none;" onclick="disconnect()">‚ùå Se d√©connecter</button>
            </div>
        </div>

        <!-- Panel de connexion -->
        <div class="connection-panel" id="connectionPanel">
            <div class="info-box">
                <strong>√âtape 1 :</strong> G√©n√©rez un ID al√©atoire ou cr√©ez le (4-14 car.).<br>
                <strong>√âtape 2 :</strong> Ouvrez la connexion pour enregistrer votre ID sur le serveur.<br>
                <strong>√âtape 3 :</strong> Entrez l'ID de votre contact pour se connecter.
            </div>

            <div class="input-group inline">
                <label>Votre nom <span style="font-size: 0.85em;">(optionnel)</span></label>
                <input type="text" id="myName" placeholder="Entrez votre nom" maxlength="18" style="width: 13ch;">
            </div>

            <div class="input-group">
               
                <div class="id-input-wrapper"> <label>Votre ID <span style="font-size: 0.85em;"></span></label>
                    <input type="text" id="myPeerId" placeholder="4 √† 14 caract√®res" maxlength="16" oninput="this.value = this.value.toLowerCase()" style="width: 20ch;">
                    <button class="btn btn-primary btn-inline" onclick="generateId()">
                        üé≤ G√©n√©rer
                    </button>
                </div>
            </div>

            <button class="btn btn-primary" id="registerBtn" onclick="registerPeer()" disabled>
                 S'enregistrer sur le serveur
            </button>

            <div class="input-group">
                <label>ID de votre contact <input type="text" id="remotePeerId" placeholder="4 √† 14 caract√®res" maxlength="18" oninput="this.value = this.value.toLowerCase()" style="width: 23ch;"></label>
            </div>

            <button class="btn btn-primary" id="connectBtn" onclick="connectToPeer()" disabled>
                [chat] Se connecter
            </button>

            <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnect()" style="display: none;">
                ‚ùå D√©connecter
            </button>
        </div>

        <!-- Zone de chat -->
        <div class="chat-container" id="chatContainer">
            <div class="voice-status" id="voiceStatus">üé§ Appel vocal en cours...</div>
            <div class="messages" id="messages"></div>
            <div class="voice-controls" id="voiceControls">
                <button class="btn-voice start" id="startVoiceBtn" onclick="startVoiceCall()">üé§ D√©marrer appel vocal</button>
                <button class="btn-voice mute" id="muteBtn" onclick="toggleMute()" style="display: none;">üîá Couper micro</button>
                <button class="btn-voice end" id="endVoiceBtn" onclick="endVoiceCall()" style="display: none;">üìû Raccrocher</button>
            </div>
            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Tapez votre message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">‚ñ∂</button>
            </div>
        </div>
        <!-- √âl√©ment audio pour le flux distant -->
        <audio id="remoteAudio" playsinline></audio>
    </div>

    <script>
        let peer = null;
        let conn = null;
        let encryptionKey = null;
        let myKeyPair = null; // Ma paire de cl√©s ECDH
        let otherPublicKey = null; // Cl√© publique de l'autre peer
        let myName = localStorage.getItem('myName') || ''; // Nom permanent
        let remoteName = ''; // Nom du correspondant
        let myStoredId = localStorage.getItem('myPeerId') || ''; // ID conserv√©
        let remoteStoredId = localStorage.getItem('remotePeerId') || ''; // ID contact conserv√©
        let inactivityTimer = null; // Timer pour d√©connexion apr√®s 10 min d'inactivit√©
        let connectionTimeout = null; // Timer pour timeout de connexion (30 secondes)
        let isConnecting = false; // Flag pour indiquer une connexion en cours
        let mediaCall = null; // Appel vocal WebRTC
        let localStream = null; // Flux audio local (microphone)
        let isMuted = false; // √âtat du micro

        // Consonnes et voyelles
        const consonnes = 'bcdfghjklmnpqrstvwxz';
        const voyelles = 'aeiouy';

        // Formater l'ID avec espaces tous les 4 caract√®res
        function formatId(id) {
            return id.match(/.{1,4}/g)?.join(' ') || id;
        }

        // Retirer les espaces d'un ID
        const unformatId = (id) => id.replace(/\s/g, '');

        // D√©marrer le timer d'inactivit√© (10 minutes)
        function startInactivityTimer() {
            clearInactivityTimer();
            console.log('D√©marrage du timer d\'inactivit√© (10 minutes)');
            inactivityTimer = setTimeout(() => {
                console.log('Timeout d\'inactivit√© atteint - D√©connexion du peer');
                if (peer && !conn) {
                    peer.destroy();
                    peer = null;
                    updateStatus('D√©connect√© (inactivit√©)', false);
                    document.getElementById('headerId').style.display = 'none';
                }
            }, 10 * 60 * 1000); // 10 minutes
        }

        // Annuler le timer d'inactivit√©
        function clearInactivityTimer() {
            if (inactivityTimer) {
                console.log('Annulation du timer d\'inactivit√©');
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
        }

        // Initialiser les champs au chargement
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Initialisation des champs depuis localStorage');
            console.log('myName:', myName, 'myStoredId:', myStoredId, 'remoteStoredId:', remoteStoredId);
            
            // Pr√©-remplir le nom
            const nameField = document.getElementById('myName');
            if (nameField && myName) { nameField.value = myName; }
            
            // Pr√©-remplir l'ID si existant
            const myIdField = document.getElementById('myPeerId');
            if (myIdField && myStoredId) {
                myIdField.value = formatId(myStoredId);
                // Activer le bouton d'enregistrement si l'ID est valide (4-14 caract√®res)
                const isValidLength = myStoredId.length >= 4 && myStoredId.length <= 14;
                document.getElementById('registerBtn').disabled = !isValidLength;
                // Activer le bouton de connexion si on a aussi l'ID du contact
                if (remoteStoredId) { 
                    document.getElementById('connectBtn').disabled = false; 
                }
            }
            
            // Activer le bouton registerBtn quand l'ID change (4-14 caract√®res accept√©s)
            myIdField.addEventListener('input', (e) => {
                let rawValue = unformatId(e.target.value).trim();
                // Limiter √† 14 caract√®res
                if (rawValue.length > 14) rawValue = rawValue.substring(0, 14);
                // Auto-formater l'ID pendant la saisie
                if (rawValue.length > 0) e.target.value = formatId(rawValue);
                // Colorer en rouge si moins de 4 caract√®res
                e.target.classList.toggle('invalid-input', rawValue.length > 0 && rawValue.length < 4);
                // Activer le bouton si entre 4 et 14 caract√®res
                document.getElementById('registerBtn').disabled = rawValue.length < 4 || rawValue.length > 14;
            });
            
            // M√™me logique pour le champ remote ID
            const remoteIdField = document.getElementById('remotePeerId');
            remoteIdField.addEventListener('input', (e) => {
                let rawValue = unformatId(e.target.value).trim();
                if (rawValue.length > 14) rawValue = rawValue.substring(0, 14);
                // Auto-formater l'ID pendant la saisie
                if (rawValue.length > 0) e.target.value = formatId(rawValue);
            });
            
            // Pr√©-remplir l'ID du contact si existant (remoteIdField d√©j√† d√©clar√© plus haut)
            if (remoteIdField && remoteStoredId) { remoteIdField.value = formatId(remoteStoredId); }
            
            // Auto-initialisation du peer si un ID existe d√©j√†
            if (myStoredId) {
                console.log('Auto-initialisation du peer avec ID sauvegard√©');
                reinitializePeerWithStoredId().catch(err => {
                    console.error('Erreur lors de l\'auto-initialisation:', err);
                });
            }
        });

        // G√©n√©rer un ID avec alternance consonne-voyelle
        // Format: CVCV CVCV CV = 10 caract√®res (C=consonne, V=voyelle)
        function generateReadableId() {
            let id = '';
            // 10 caract√®res en alternance C-V-C-V...
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 0) {
                    // Positions paires (0,2,4,6,8) = consonnes
                    id += consonnes[Math.floor(Math.random() * consonnes.length)];
                } else {
                    // Positions impaires (1,3,5,7,9) = voyelles
                    id += voyelles[Math.floor(Math.random() * voyelles.length)];
                }
            }
            return id;
        }

        // G√©n√©rer un ID al√©atoire et l'afficher dans le champ
        function generateId() {
            const randomId = generateReadableId();
            const idField = document.getElementById('myPeerId');
            idField.value = formatId(randomId); // Format√© avec espaces : xxxx xxxx xx
            idField.readOnly = false;
            document.getElementById('registerBtn').disabled = false;
            console.log('ID g√©n√©r√©:', randomId);
        }

        // G√©n√©ration d'une paire de cl√©s ECDH (cryptage asym√©trique)
        async function generateKeyPair() {
            const keyPair = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: 'P-384' // Courbe elliptique s√©curis√©e
                },
                true,
                ['deriveKey']
            );
            console.log('Paire de cl√©s ECDH g√©n√©r√©e');
            return keyPair;
        }

        // D√©river une cl√© AES partag√©e √† partir de ma cl√© priv√©e et la cl√© publique de l'autre
        async function deriveSharedKey(myPrivateKey, theirPublicKey) {
            const sharedKey = await crypto.subtle.deriveKey(
                {
                    name: 'ECDH',
                    public: theirPublicKey
                },
                myPrivateKey,
                {
                    name: 'AES-GCM',
                    length: 256
                },
                false,
                ['encrypt', 'decrypt']
            );
            console.log('Cl√© partag√©e d√©riv√©e avec succ√®s');
            return sharedKey;
        }

        // Cryptage d'un message avec AES-GCM
        async function encryptMessage(message, key) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            // Combine IV + encrypted data
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return btoa(String.fromCharCode(...combined));
        }

        // D√©cryptage d'un message
        async function decryptMessage(encryptedData, key) {
            try {
                const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const data = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (e) {
                console.error('Erreur de d√©cryptage:', e);
                return '[Message non d√©cryptable]';
            }
        }

        // Export de la cl√© publique pour l'√©change
        async function exportPublicKey(publicKey) {
            const exported = await crypto.subtle.exportKey('spki', publicKey);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        // Import de la cl√© publique re√ßue
        async function importPublicKey(keyData) {
            const rawKey = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
            return await crypto.subtle.importKey(
                'spki',
                rawKey,
                {
                    name: 'ECDH',
                    namedCurve: 'P-384'
                },
                true,
                []
            );
        }

        // Configuration par d√©faut du peer
        const getPeerConfig = () => ({
            host: '0.peerjs.com',
            secure: true,
            port: 443,
            path: '/',
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ]
            }
        });

        // Mettre √† jour l'affichage de l'ID dans le header
        function updateHeaderId(id) {
            const headerIdElement = document.getElementById('headerId');
            const headerText = myName 
                ? `${myName}, <strong>ID:</strong> ${formatId(id)}`
                : `<strong>ID:</strong> ${formatId(id)}`;
            headerIdElement.innerHTML = headerText;
            headerIdElement.style.display = 'block';
        }

        // R√©initialiser le peer avec l'ID stock√© (lors du rechargement de page)
        async function reinitializePeerWithStoredId() {
            console.log('R√©initialisation automatique du peer avec ID conserv√©:', myStoredId);
            
            // G√©n√©rer la paire de cl√©s ECDH
            myKeyPair = await generateKeyPair();
            console.log('Paire de cl√©s ECDH cr√©√©e');
            
            // Retourner une promesse qui se r√©sout quand le peer est ouvert
            return new Promise((resolve, reject) => {
                // Utiliser l'ID conserv√©
                peer = new Peer(myStoredId, getPeerConfig());

                peer.on('open', (id) => {
                    document.getElementById('connectBtn').disabled = false;
                    updateStatus('En attente de connexion...', 'waiting');
                    
                    // Afficher l'ID dans le header
                    updateHeaderId(id);
                    
                    // D√©marrer le timer d'inactivit√©
                    startInactivityTimer();
                    
                    console.log('Peer r√©initialis√© avec ID:', id);
                    resolve(); // R√©soudre la promesse quand le peer est ouvert
                });

                peer.on('connection', async (connection) => {
                    conn = connection;
                    setupConnection();
                    updateStatus('Connexion entrante...', false);
                });

                // G√©rer les appels vocaux entrants
                peer.on('call', (call) => {
                    console.log('Appel vocal entrant...');
                    answerVoiceCall(call);
                });

                peer.on('error', (err) => {
                    console.error('Erreur PeerJS lors de la r√©initialisation:', err);
                    // En cas d'erreur, l'utilisateur devra re-g√©n√©rer un ID
                    document.getElementById('connectBtn').disabled = true;
                    reject(err); // Rejeter la promesse en cas d'erreur
                });
            });
        }

        // Enregistrer le peer avec l'ID choisi
        async function registerPeer() {
            const registerBtn = document.getElementById('registerBtn');
            registerBtn.disabled = true;
            registerBtn.textContent = '‚è≥ Connexion en cours...';

            // Sauvegarder le nom (m√™me s'il est vide)
            const nameInput = document.getElementById('myName');
            myName = nameInput.value.trim();
            localStorage.setItem('myName', myName);

            // Si un peer existe d√©j√†, le d√©truire avant d'en cr√©er un nouveau
            if (peer) {
                peer.destroy();
            }

            // R√©cup√©rer et valider l'ID
            const myId = unformatId(document.getElementById('myPeerId').value).trim().toLowerCase();
            
            if (myId.length < 4 || myId.length > 14) {
                alert('L\'ID doit contenir entre 4 et 14 caract√®res');
                registerBtn.disabled = false;
                registerBtn.textContent = 'üöÄ S\'enregistrer sur le serveur';
                return;
            }
            
            // G√©n√©rer la paire de cl√©s ECDH
            myKeyPair = await generateKeyPair();
            console.log('Paire de cl√©s ECDH cr√©√©e');
            console.log('Enregistrement avec ID:', myId);
            
            // Utiliser le serveur officiel de PeerJS
            peer = new Peer(myId, getPeerConfig());

            peer.on('open', (id) => {
                // Sauvegarder l'ID dans localStorage
                myStoredId = id;
                localStorage.setItem('myPeerId', id);
                
                document.getElementById('myPeerId').value = formatId(id);
                document.getElementById('myPeerId').readOnly = true;
                document.getElementById('connectBtn').disabled = false;
                updateStatus('En attente de connexion...', 'waiting');
                registerBtn.textContent = '‚úÖ Connect√© au serveur';
                registerBtn.disabled = true;
                
                // Afficher l'ID dans le header
                updateHeaderId(id);
                
                // D√©marrer le timer d'inactivit√©
                startInactivityTimer();
                
                console.log('Mon Peer ID:', id);
            });

            peer.on('connection', async (connection) => {
                conn = connection;
                setupConnection();
                updateStatus('Connexion entrante...', false);
            });

            // G√©rer les appels vocaux entrants
            peer.on('call', (call) => {
                console.log('Appel vocal entrant...');
                answerVoiceCall(call);
            });

            peer.on('error', (err) => {
                console.error('Erreur PeerJS:', err);
                alert('Erreur: ' + err.message);
                registerBtn.disabled = false;
                registerBtn.textContent = 'üöÄ S\'enregistrer sur le serveur';
                document.getElementById('myPeerId').readOnly = false;
            });
        }

        // R√©initialiser le bouton de connexion
        function resetConnectButton() {
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.textContent = '[chat] Se connecter';
            connectBtn.onclick = connectToPeer;
            connectBtn.disabled = false;
            connectBtn.removeAttribute('disabled');
        }

        // Annuler la tentative de connexion en cours
        function cancelConnection() {
            console.log('Annulation de la connexion en cours...');
            
            // Annuler le timeout
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            
            // Fermer la connexion
            if (conn) conn.close();
            conn = null;
            
            // R√©initialiser le flag et restaurer l'interface
            isConnecting = false;
            resetConnectButton();
            
            // Remettre le statut
            updateStatus('En attente de connexion...', 'waiting');
            
            // R√©activer le champ ID du contact
            document.getElementById('remotePeerId').disabled = false;
            
            console.log('Connexion annul√©e - vous pouvez r√©essayer');
        }

        // Se connecter √† un peer
        async function connectToPeer() {
            // Si d√©j√† en train de se connecter, ne rien faire
            if (isConnecting) {
                return;
            }
            
            const remotePeerId = unformatId(document.getElementById('remotePeerId').value).trim().toLowerCase();
            
            if (remotePeerId.length < 4 || remotePeerId.length > 14) {
                alert('Veuillez entrer un ID valide (4 √† 14 caract√®res)');
                return;
            }
            
            // Sauvegarder l'ID du contact
            remoteStoredId = remotePeerId;
            localStorage.setItem('remotePeerId', remotePeerId);

            // MODIFIER LE BOUTON IMM√âDIATEMENT pour permettre l'annulation
            const connectBtn = document.getElementById('connectBtn');
            console.log('üîß AVANT: connectBtn.disabled =', connectBtn.disabled);
            connectBtn.textContent = '‚ùå Annuler la connexion';
            connectBtn.onclick = cancelConnection;
            connectBtn.disabled = false; // Activer le bouton
            connectBtn.removeAttribute('disabled'); // FORCER le retrait de l'attribut disabled
            console.log('üîß APR√àS: connectBtn.disabled =', connectBtn.disabled);
            console.log('üîß Bouton doit √™tre ACTIF maintenant - version v0.50');
            isConnecting = true;
            
            // D√©sactiver le champ ID du contact pendant la connexion
            document.getElementById('remotePeerId').disabled = true;
            
            updateStatus('Connexion en cours...', 'waiting');

            // Si pas de peer, cr√©er un peer avec l'ID conserv√©
            if (!peer) {
                if (myStoredId) {
                    console.log('Cr√©ation du peer avec ID conserv√© avant connexion');
                    try {
                        await reinitializePeerWithStoredId();
                        console.log('Peer pr√™t, connexion en cours...');
                    } catch (err) {
                        alert('Erreur lors de l\'initialisation: ' + err.message);
                        // Restaurer le bouton en cas d'erreur
                        isConnecting = false;
                        resetConnectButton();
                        document.getElementById('remotePeerId').disabled = false;
                        return;
                    }
                } else {
                    alert('Veuillez d\'abord g√©n√©rer votre ID');
                    // Restaurer le bouton en cas d'erreur
                    isConnecting = false;
                    resetConnectButton();
                    document.getElementById('remotePeerId').disabled = false;
                    return;
                }
            }
            
            conn = peer.connect(remotePeerId, {
                reliable: true
            });
            
            // D√©marrer le timeout de 30 secondes
            connectionTimeout = setTimeout(() => {
                if (isConnecting && conn && !conn.open) {
                    console.log('Timeout de connexion atteint (30 secondes)');
                    
                    // Fermer la connexion √©chou√©e
                    conn.close();
                    conn = null;
                    isConnecting = false;
                    
                    // Restaurer l'interface
                    resetConnectButton();
                    
                    // R√©activer le champ
                    document.getElementById('remotePeerId').disabled = false;
                    
                    updateStatus('√âchec de connexion (timeout)', 'disconnected');
                    alert('‚ùå Impossible de se connecter √† cet ID.\n\nV√©rifiez que :\n‚Ä¢ L\'ID est correct\n‚Ä¢ Votre contact a bien ouvert sa connexion\n‚Ä¢ Votre contact est en ligne\n\nVous pouvez r√©essayer avec un autre ID.');
                }
            }, 30000); // 30 secondes
            
            setupConnection();
        }

        // Configuration de la connexion
        async function setupConnection() {
            conn.on('open', async () => {
                // Annuler le timer d'inactivit√© car la connexion est √©tablie
                clearInactivityTimer();
                
                // Annuler le timeout de connexion car la connexion a r√©ussi
                if (connectionTimeout) {
                    clearTimeout(connectionTimeout);
                    connectionTimeout = null;
                }
                
                // R√©initialiser le flag de connexion et restaurer le bouton
                isConnecting = false;
                resetConnectButton();
                
                // R√©activer le champ
                document.getElementById('remotePeerId').disabled = false;
                
                updateStatus('Connect√©', 'connected');
                document.getElementById('connectionPanel').classList.add('hidden');
                document.getElementById('chatContainer').classList.add('active');
                document.getElementById('disconnectBtn').style.display = 'block';
                document.getElementById('encryptionBadge').style.display = 'inline-block';
                document.getElementById('disconnectBadge').style.display = 'inline-block';
                document.getElementById('voiceControls').classList.add('active');

                // V√©rifier que la paire de cl√©s ECDH existe
                if (!myKeyPair) {
                    console.error('Erreur: paire de cl√©s ECDH non initialis√©e');
                    addSystemMessage('‚ö†Ô∏è Erreur: cl√©s de chiffrement manquantes. Veuillez re-g√©n√©rer votre ID.');
                    return;
                }

                // Exporter et envoyer ma cl√© publique √† l'autre peer
                try {
                    const myPublicKeyData = await exportPublicKey(myKeyPair.publicKey);
                    conn.send({ type: 'public-key', data: myPublicKeyData });
                    
                    // Envoyer mon nom
                    conn.send({ type: 'name', data: myName });
                    
                    console.log('Cl√© publique ECDH et nom envoy√©s');
                    addSystemMessage('üîê √âchange de cl√©s en cours...');
                } catch (e) {
                    console.error('Erreur lors de l\'export de la cl√©:', e);
                    addSystemMessage('‚ö†Ô∏è Erreur lors de l\'export de la cl√© publique');
                }
            });

            conn.on('data', async (data) => {
                console.log('Donn√©es re√ßues:', data.type);
                
                // Ignorer les keepalive
                if (data.type === 'keepalive') {
                    return;
                }
                
                if (data.type === 'name') {
                    // Recevoir le nom du correspondant
                    remoteName = data.data;
                    updateStatus('Connect√© avec ' + remoteName, 'connected');
                    console.log('Nom du correspondant:', remoteName);
                } else if (data.type === 'public-key') {
                    // Recevoir la cl√© publique de l'autre peer
                    try {
                        console.log('R√©ception de la cl√© publique de l\'autre peer...');
                        
                        if (!myKeyPair) {
                            throw new Error('Ma paire de cl√©s ECDH n\'est pas initialis√©e');
                        }
                        
                        otherPublicKey = await importPublicKey(data.data);
                        console.log('Cl√© publique de l\'autre peer import√©e avec succ√®s');
                        
                        // D√©river la cl√© partag√©e
                        encryptionKey = await deriveSharedKey(myKeyPair.privateKey, otherPublicKey);
                        console.log('Cl√© partag√©e d√©riv√©e avec ECDH P-384');
                        
                        addSystemMessage('üîê Connexion √©tablie et crypt√©e (ECDH P-384) !');
                        
                        // Envoyer confirmation
                        conn.send({ type: 'key-ready' });
                    } catch (e) {
                        console.error('Erreur √©change de cl√©s:', e);
                        addSystemMessage('‚ö†Ô∏è Erreur lors de l\'√©change de cl√©s: ' + e.message);
                    }
                } else if (data.type === 'key-ready') {
                    // L'autre peer a termin√© le d√©rivation de cl√©
                    console.log('Confirmation: l\'autre peer est pr√™t');
                    addSystemMessage('üîê Connexion √©tablie et crypt√©e (ECDH P-384) !');
                } else if (data.type === 'message') {
                    // Attendre que la cl√© soit disponible
                    if (!encryptionKey) {
                        console.error('Cl√© de cryptage non disponible');
                        addMessage('[En attente de la cl√© de cryptage...]', 'received');
                        return;
                    }
                    
                    // D√©chiffrer et afficher le message
                    try {
                        console.log('Tentative de d√©cryptage du message...');
                        const decryptedMessage = await decryptMessage(data.data, encryptionKey);
                        console.log('Message d√©crypt√©:', decryptedMessage);
                        addMessage(decryptedMessage, 'received');
                    } catch (e) {
                        console.error('Erreur de d√©cryptage:', e);
                        addMessage('[Erreur de d√©cryptage]', 'received');
                    }
                }
            });

            conn.on('close', () => {
                updateStatus('D√©connect√©', 'disconnected');
                addSystemMessage('‚ùå Connexion ferm√©e par le correspondant');
                // Recharger la page pour r√©initialiser proprement
                setTimeout(() => {
                    location.reload();
                }, 2000); // Attendre 2 secondes pour que l'utilisateur voie le message
            });

            conn.on('error', (err) => {
                console.error('Erreur de connexion:', err);
                addSystemMessage('‚ö†Ô∏è Erreur de connexion');
            });
        }

        // Envoyer un message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !conn) return;
            
            // V√©rifier que la cl√© est disponible
            if (!encryptionKey) {
                alert('‚ö†Ô∏è Cl√© de cryptage non disponible. Attendez la synchronisation...');
                return;
            }

            try {
                console.log('Cryptage du message:', message);
                const encryptedMessage = await encryptMessage(message, encryptionKey);
                console.log('Message crypt√©, envoi...');
                conn.send({ type: 'message', data: encryptedMessage });
                addMessage(message, 'sent');
                input.value = '';
            } catch (e) {
                console.error('Erreur d\'envoi:', e);
                addSystemMessage('‚ö†Ô∏è Erreur d\'envoi du message');
            }
        }

        // G√©rer la touche Entr√©e
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Ajouter un message √† l'interface
        function addMessage(text, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const now = new Date();
            const time = [now.getHours(), now.getMinutes()]
                .map(n => n.toString().padStart(2, '0'))
                .join(':');
            
            messageDiv.innerHTML = `
                <div class="message-content">
                    ${escapeHtml(text)}
                    <div class="message-time">${time}</div>
                </div>
            `;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Ajouter un message syst√®me
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            Object.assign(messageDiv.style, {
                textAlign: 'center',
                color: '#6c757d',
                fontSize: '14px',
                margin: '10px 0'
            });
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // √âchapper le HTML
        const escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        // Mettre √† jour le statut
        // state: 'disconnected' (rouge), 'waiting' (jaune anim√©), 'connected' (vert fixe)
        function updateStatus(text, state) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            
            // Retirer toutes les classes d'√©tat
            indicator.classList.remove('connected', 'waiting');
            
            // Ajouter la classe appropri√©e selon l'√©tat
            if (state === 'connected') {
                indicator.classList.add('connected');
            } else if (state === 'waiting') {
                indicator.classList.add('waiting');
            }
            // Si 'disconnected' ou false, pas de classe = rouge par d√©faut
        }

        // D√©marrer un appel vocal
        async function startVoiceCall() {
            if (!peer || !conn) {
                alert('‚ö†Ô∏è Veuillez d\'abord √©tablir une connexion chat');
                return;
            }

            // V√©rifier que la connexion est toujours ouverte
            if (!conn.open) {
                alert('‚ö†Ô∏è La connexion chat est ferm√©e. Reconnectez-vous.');
                return;
            }

            // Keepalive pour maintenir la connexion pendant demande permission
            let keepaliveInterval = null;
            
            try {
                console.log('Demande d\'acc√®s au microphone...');
                addSystemMessage('üé§ Autorisation microphone requise...');
                
                // Envoyer des pings r√©guliers pour garder connexion active
                keepaliveInterval = setInterval(() => {
                    if (conn && conn.open) {
                        try {
                            conn.send({ type: 'keepalive', timestamp: Date.now() });
                            console.log('Keepalive envoy√©');
                        } catch (e) {
                            console.warn('Erreur keepalive:', e);
                        }
                    }
                }, 2000); // Ping toutes les 2 secondes
                
                // Demander permission microphone
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Arr√™ter le keepalive
                if (keepaliveInterval) {
                    clearInterval(keepaliveInterval);
                    keepaliveInterval = null;
                }
                
                console.log('Microphone activ√©');
                
                // V√©rifier la connexion apr√®s permission
                if (!conn || !conn.open) {
                    throw new Error('Connexion perdue pendant l\'acc√®s au microphone');
                }
                
                console.log('D√©marrage de l\'appel...');
                
                // Appeler le peer distant
                mediaCall = peer.call(remoteStoredId, localStream);
                
                if (!mediaCall) {
                    throw new Error('Impossible de cr√©er l\'appel');
                }

                // Recevoir le flux audio distant
                mediaCall.on('stream', (remoteStream) => {
                    console.log('Flux audio distant re√ßu');
                    const remoteAudio = document.getElementById('remoteAudio');
                    remoteAudio.srcObject = remoteStream;
                    // Forcer la lecture avec gestion d'erreur pour mobile
                    remoteAudio.play().catch(e => {
                        console.warn('Autoplay bloqu√©, tentative avec interaction:', e);
                        // Sur mobile, demander une interaction utilisateur
                        addSystemMessage('üîä Cliquez pour activer le son');
                        document.addEventListener('click', function playAudio() {
                            remoteAudio.play().then(() => {
                                console.log('Audio activ√© apr√®s interaction');
                                document.removeEventListener('click', playAudio);
                            });
                        }, { once: true });
                    });
                });

                mediaCall.on('close', () => {
                    console.log('Appel termin√© par l\'autre peer');
                    endVoiceCall();
                    addSystemMessage('üìû Appel vocal termin√©');
                });

                mediaCall.on('error', (err) => {
                    console.error('Erreur d\'appel:', err);
                    addSystemMessage('‚ö†Ô∏è Erreur lors de l\'appel vocal: ' + err.message);
                    endVoiceCall();
                });

                // Mettre √† jour l'interface
                document.getElementById('startVoiceBtn').style.display = 'none';
                document.getElementById('muteBtn').style.display = 'block';
                document.getElementById('endVoiceBtn').style.display = 'block';
                document.getElementById('voiceStatus').classList.add('active');
                
                addSystemMessage('üé§ Appel vocal d√©marr√©');
                console.log('Appel vocal actif');
            } catch (err) {
                console.error('Erreur appel vocal:', err);
                
                // Arr√™ter le keepalive en cas d'erreur
                if (keepaliveInterval) {
                    clearInterval(keepaliveInterval);
                    keepaliveInterval = null;
                }
                
                // Nettoyer le flux si cr√©√©
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                let errorMsg = '‚ùå Impossible de d√©marrer l\'appel vocal.\n\n';
                
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    errorMsg += 'Permission micro refus√©e.\nAutorisez l\'acc√®s au microphone dans les param√®tres.';
                } else if (err.name === 'NotFoundError') {
                    errorMsg += 'Aucun microphone d√©tect√©.\nV√©rifiez votre mat√©riel.';
                } else if (err.message && err.message.includes('Connexion perdue')) {
                    errorMsg += 'Connexion perdue pendant l\'acc√®s au micro.\nReconnectez-vous et r√©essayez.';
                } else if (err.message && err.message.includes('Timeout')) {
                    errorMsg += 'D√©lai d\'attente d√©pass√©.\nV√©rifiez les permissions et r√©essayez.';
                } else {
                    errorMsg += 'Erreur: ' + err.message;
                }
                
                alert(errorMsg);
                addSystemMessage('‚ö†Ô∏è √âchec d√©marrage appel vocal');
            }
        }

        // R√©pondre √† un appel vocal entrant
        async function answerVoiceCall(call) {
            // Keepalive pour maintenir la connexion
            let keepaliveInterval = null;
            
            try {
                console.log('R√©ponse √† l\'appel entrant...');
                addSystemMessage('üé§ Appel entrant, autorisation micro...');
                
                // V√©rifier la connexion
                if (!conn || !conn.open) {
                    throw new Error('Connexion ferm√©e');
                }
                
                // Keepalive pendant demande permission
                keepaliveInterval = setInterval(() => {
                    if (conn && conn.open) {
                        try {
                            conn.send({ type: 'keepalive', timestamp: Date.now() });
                            console.log('Keepalive envoy√© (r√©ponse)');
                        } catch (e) {
                            console.warn('Erreur keepalive:', e);
                        }
                    }
                }, 2000);
                
                // Demander acc√®s au microphone
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Arr√™ter keepalive
                if (keepaliveInterval) {
                    clearInterval(keepaliveInterval);
                    keepaliveInterval = null;
                }
                
                // V√©rifier connexion
                if (!conn || !conn.open) {
                    throw new Error('Connexion perdue pendant l\'acc√®s au microphone');
                }
                
                // R√©pondre √† l'appel avec notre flux audio
                call.answer(localStream);
                mediaCall = call;
                
                // Recevoir le flux audio distant
                call.on('stream', (remoteStream) => {
                    console.log('Flux audio distant re√ßu (appel entrant)');
                    const remoteAudio = document.getElementById('remoteAudio');
                    remoteAudio.srcObject = remoteStream;
                    // Forcer la lecture avec gestion d'erreur pour mobile
                    remoteAudio.play().catch(e => {
                        console.warn('Autoplay bloqu√©, tentative avec interaction:', e);
                        // Sur mobile, demander une interaction utilisateur
                        addSystemMessage('üîä Cliquez pour activer le son');
                        document.addEventListener('click', function playAudio() {
                            remoteAudio.play().then(() => {
                                console.log('Audio activ√© apr√®s interaction');
                                document.removeEventListener('click', playAudio);
                            });
                        }, { once: true });
                    });
                });

                call.on('close', () => {
                    console.log('Appel termin√© par l\'autre peer');
                    endVoiceCall();
                    addSystemMessage('üìû Appel vocal termin√©');
                });

                call.on('error', (err) => {
                    console.error('Erreur d\'appel:', err);
                    endVoiceCall();
                });

                // Mettre √† jour l'interface
                document.getElementById('startVoiceBtn').style.display = 'none';
                document.getElementById('muteBtn').style.display = 'block';
                document.getElementById('endVoiceBtn').style.display = 'block';
                document.getElementById('voiceStatus').classList.add('active');
                
                addSystemMessage('üé§ Appel vocal accept√©');
                console.log('Appel vocal actif (entrant)');
            } catch (err) {
                console.error('Erreur r√©ponse appel:', err);
                
                // Arr√™ter keepalive
                if (keepaliveInterval) {
                    clearInterval(keepaliveInterval);
                    keepaliveInterval = null;
                }
                
                // Nettoyer
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                let errorMsg = '‚ùå Impossible de r√©pondre √† l\'appel.\n\n';
                
                if (err.name === 'NotAllowedError') {
                    errorMsg += 'Permission micro refus√©e.';
                } else if (err.message && err.message.includes('Connexion')) {
                    errorMsg += 'Connexion perdue. Reconnectez-vous.';
                } else {
                    errorMsg += 'Erreur: ' + err.message;
                }
                
                alert(errorMsg);
                addSystemMessage('‚ö†Ô∏è √âchec r√©ponse appel');
            }
        }

        // Terminer l'appel vocal
        function endVoiceCall() {
            console.log('Fin de l\'appel vocal...');
            
            // Fermer l'appel MediaConnection
            if (mediaCall) {
                mediaCall.close();
                mediaCall = null;
            }
            
            // Arr√™ter le flux local (microphone)
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Arr√™ter le flux distant
            const remoteAudio = document.getElementById('remoteAudio');
            if (remoteAudio.srcObject) {
                remoteAudio.srcObject.getTracks().forEach(track => track.stop());
                remoteAudio.srcObject = null;
            }
            
            // R√©initialiser l'interface
            document.getElementById('startVoiceBtn').style.display = 'block';
            document.getElementById('muteBtn').style.display = 'none';
            document.getElementById('endVoiceBtn').style.display = 'none';
            document.getElementById('voiceStatus').classList.remove('active');
            
            // R√©initialiser l'√©tat du micro
            isMuted = false;
            const muteBtn = document.getElementById('muteBtn');
            muteBtn.textContent = 'üîá Couper micro';
            muteBtn.classList.remove('active');
            
            console.log('Appel vocal termin√©');
        }

        // Couper/r√©activer le microphone
        function toggleMute() {
            if (!localStream) return;
            
            const audioTrack = localStream.getAudioTracks()[0];
            if (!audioTrack) return;
            
            isMuted = !isMuted;
            audioTrack.enabled = !isMuted;
            
            const muteBtn = document.getElementById('muteBtn');
            if (isMuted) {
                muteBtn.textContent = 'üîä Activer micro';
                muteBtn.classList.add('active');
                addSystemMessage('üîá Micro coup√©');
            } else {
                muteBtn.textContent = 'üîá Couper micro';
                muteBtn.classList.remove('active');
                addSystemMessage('üîä Micro activ√©');
            }
            
            console.log('Micro:', isMuted ? 'coup√©' : 'activ√©');
        }

        // D√©connecter
        function disconnect() {
            // Annuler le timer d'inactivit√©
            clearInactivityTimer();
            
            // Terminer l'appel vocal si actif
            if (mediaCall || localStream) {
                endVoiceCall();
            }
            
            if (conn) conn.close();
            if (peer) peer.destroy();
            conn = null;
            peer = null;
            resetChat();
        }

        // R√©initialiser le chat
        function resetChat() {
            // Revenir √† l'√©cran de connexion
            document.getElementById('connectionPanel').classList.remove('hidden');
            document.getElementById('chatContainer').classList.remove('active');
            document.getElementById('messages').innerHTML = '';
            document.getElementById('encryptionBadge').style.display = 'none';
            document.getElementById('disconnectBadge').style.display = 'none';
            document.getElementById('disconnectBtn').style.display = 'none';
            
            // R√©initialiser les cl√©s
            encryptionKey = null;
            myKeyPair = null;
            otherPublicKey = null;
            remoteName = '';
            
            // Masquer les contr√¥les vocaux
            document.getElementById('voiceControls').classList.remove('active');
            document.getElementById('voiceStatus').classList.remove('active');
            
            // Remettre les champs en lecture/√©criture et pr√©-remplis
            const myIdField = document.getElementById('myPeerId');
            myIdField.readOnly = false;
            if (myStoredId) {
                myIdField.value = formatId(myStoredId);
                const isValidLength = myStoredId.length >= 4 && myStoredId.length <= 14;
                document.getElementById('registerBtn').disabled = !isValidLength;
            }
            
            // Pr√©-remplir le nom
            const nameField = document.getElementById('myName');
            if (myName) {
                nameField.value = myName;
            }
            
            // Pr√©-remplir l'ID du contact
            const remoteIdField = document.getElementById('remotePeerId');
            if (remoteStoredId) {
                remoteIdField.value = formatId(remoteStoredId);
            }
            
            // Cacher l'ID du header
            document.getElementById('headerId').style.display = 'none';
            
            // Remettre le statut √† d√©connect√©
            updateStatus('D√©connect√©', 'disconnected');
            
            // D√©sactiver le bouton de connexion jusqu'√† r√©enregistrement du peer
            document.getElementById('connectBtn').disabled = true;
            
            // Remettre le texte du bouton register
            const registerBtn = document.getElementById('registerBtn');
            registerBtn.textContent = 'üöÄ S\'enregistrer sur le serveur';
        }

        // Enregistrer le Service Worker pour PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Charger le nom sauvegard√©
                const nameInput = document.getElementById('myName');
                if (myName && myName !== 'Anonyme') {
                    nameInput.value = myName;
                }

                // D√©senregistrer tous les anciens service workers pour forcer la mise √† jour
                navigator.serviceWorker.getRegistrations().then((registrations) => {
                    for (let registration of registrations) {
                        registration.unregister();
                    }
                }).then(() => {
                    // Enregistrer le nouveau service worker avec param√®tre de version
                    navigator.serviceWorker.register('./service-worker.js?v=46')
                        .then((registration) => {
                            console.log('Service Worker v39 enregistr√© avec succ√®s:', registration.scope);
                            // Forcer la mise √† jour imm√©diate
                            registration.update();
                        })
                        .catch((error) => {
                            console.log('Erreur d\'enregistrement du Service Worker:', error);
                        });
                });
            });
        }
    </script>
</body>
</html>




