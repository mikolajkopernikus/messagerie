<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chat peer-to-peer crypt√© avec PeerJS">
    <meta name="theme-color" content="#2c3e50">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="P2P Chat">
    <title>Chat Crypt√© P2P - PeerJS</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .header-id {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            color: #4CAF50;
            font-weight: 600;
            display: none;
            max-width: 150px;
            word-break: break-all;
        }

        .status {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .connection-panel {
            padding: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #495057;
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3a3a3a 0%, #2c3e50 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .chat-container {
            display: none;
            flex-direction: column;
            height: 500px;
        }

        .chat-container.active {
            display: flex;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }

        .message.sent {
            justify-content: flex-end;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .message.received .message-content {
            background: white;
            border: 1px solid #dee2e6;
            border-bottom-left-radius: 4px;
        }

        .message.sent .message-content {
            background: linear-gradient(135deg, #4a4a4a 0%, #2c3e50 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 4px;
        }

        .input-container {
            padding: 15px;
            background: white;
            border-top: 1px solid #dee2e6;
            display: flex;
            gap: 10px;
        }

        .input-container input {
            flex: 1;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            font-size: 16px;
        }

        .input-container input:focus {
            outline: none;
            border-color: #495057;
        }

        .input-container button {
            padding: 12px 20px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2c3e50 100%);
            color: white;
            border: none;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .input-container button:hover {
            transform: scale(1.05);
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 14px;
        }

        .encryption-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Messagerie Point √† Point Crypt√©e</h1>
            <p>v0.10</p>
            <div class="header-id" id="headerId"></div>
        </div>

        <div class="status">
            <div class="status-indicator" id="statusIndicator"></div>
            <div>
                <strong id="statusText">D√©connect√©</strong>
                <span class="encryption-badge" id="encryptionBadge" style="display: none;">üîí ECDH P-384</span>
            </div>
        </div>

        <!-- Panel de connexion -->
        <div class="connection-panel" id="connectionPanel">
            <div class="info-box">
                <strong>Mode 1 :</strong> G√©n√®re votre ID et partagez-le.<br>
                <strong>Mode 2 :</strong> Entrez l'ID de votre ami pour vous connecter.
            </div>

            <div class="input-group">
                <label>Votre ID (sera g√©n√©r√© automatiquement)</label>
                <input type="text" id="myPeerId" readonly placeholder="Cliquez sur Initialiser...">
            </div>

            <button class="btn btn-primary" id="initBtn" onclick="initializePeer()">
                üöÄ Initialiser ma connexion
            </button>

            <div class="input-group">
                <label>ID de votre correspondant</label>
                <input type="text" id="remotePeerId" placeholder="Entrez l'ID √† contacter" oninput="this.value = this.value.toLowerCase()">
            </div>

            <button class="btn btn-primary" id="connectBtn" onclick="connectToPeer()" disabled>
                üìû Se connecter
            </button>

            <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnect()" style="display: none;">
                ‚ùå D√©connecter
            </button>
        </div>

        <!-- Zone de chat -->
        <div class="chat-container" id="chatContainer">
            <div class="messages" id="messages"></div>
            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Tapez votre message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">‚ñ∂</button>
            </div>
        </div>
    </div>

    <script>
        let peer = null;
        let conn = null;
        let encryptionKey = null;
        let myKeyPair = null; // Ma paire de cl√©s ECDH
        let otherPublicKey = null; // Cl√© publique de l'autre peer

        // Calculer la lettre de contr√¥le (checksum)
        function calculateChecksum(id) {
            let sum = 0;
            for (let i = 0; i < id.length; i++) {
                sum += id.charCodeAt(i);
            }
            const checkChar = String.fromCharCode(97 + (sum % 26)); // a-z
            return checkChar;
        }

        // V√©rifier la lettre de contr√¥le
        function verifyChecksum(idWithCheck) {
            if (idWithCheck.length < 2) return false;
            const id = idWithCheck.slice(0, -1);
            const checkChar = idWithCheck.slice(-1);
            return calculateChecksum(id) === checkChar;
        }

        // G√©n√©ration d'une paire de cl√©s ECDH (cryptage asym√©trique)
        async function generateKeyPair() {
            const keyPair = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: 'P-384' // Courbe elliptique s√©curis√©e
                },
                true,
                ['deriveKey']
            );
            console.log('Paire de cl√©s ECDH g√©n√©r√©e');
            return keyPair;
        }

        // D√©river une cl√© AES partag√©e √† partir de ma cl√© priv√©e et la cl√© publique de l'autre
        async function deriveSharedKey(myPrivateKey, theirPublicKey) {
            const sharedKey = await crypto.subtle.deriveKey(
                {
                    name: 'ECDH',
                    public: theirPublicKey
                },
                myPrivateKey,
                {
                    name: 'AES-GCM',
                    length: 256
                },
                false,
                ['encrypt', 'decrypt']
            );
            console.log('Cl√© partag√©e d√©riv√©e avec succ√®s');
            return sharedKey;
        }

        // Cryptage d'un message avec AES-GCM
        async function encryptMessage(message, key) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            
            // Combine IV + encrypted data
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return btoa(String.fromCharCode(...combined));
        }

        // D√©cryptage d'un message
        async function decryptMessage(encryptedData, key) {
            try {
                const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const data = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (e) {
                console.error('Erreur de d√©cryptage:', e);
                return '[Message non d√©cryptable]';
            }
        }

        // Export de la cl√© publique pour l'√©change
        async function exportPublicKey(publicKey) {
            const exported = await crypto.subtle.exportKey('spki', publicKey);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        // Import de la cl√© publique re√ßue
        async function importPublicKey(keyData) {
            const rawKey = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
            return await crypto.subtle.importKey(
                'spki',
                rawKey,
                {
                    name: 'ECDH',
                    namedCurve: 'P-384'
                },
                true,
                []
            );
        }

        // Initialiser PeerJS
        async function initializePeer() {
            const initBtn = document.getElementById('initBtn');
            initBtn.disabled = true;
            initBtn.textContent = '‚è≥ Initialisation...';

            // G√©n√©rer la paire de cl√©s ECDH d√®s le d√©but
            myKeyPair = await generateKeyPair();
            console.log('Paire de cl√©s ECDH cr√©√©e');

            // G√©n√©rer un ID al√©atoire simple avec lettre de contr√¥le
            const baseId = 'user-' + Math.random().toString(36).substr(2, 9);
            const checkChar = calculateChecksum(baseId);
            const randomId = baseId + checkChar;
            console.log('ID g√©n√©r√© avec checksum:', randomId);
            
            // Utiliser le serveur officiel de PeerJS
            peer = new Peer(randomId, {
                host: '0.peerjs.com',
                secure: true,
                port: 443,
                path: '/',
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            });

            peer.on('open', (id) => {
                document.getElementById('myPeerId').value = id;
                document.getElementById('connectBtn').disabled = false;
                updateStatus('En attente de connexion...', false);
                initBtn.textContent = '‚úÖ Initialis√©';
                
                // Afficher l'ID dans le header
                const headerIdElement = document.getElementById('headerId');
                headerIdElement.textContent = id;
                headerIdElement.style.display = 'block';
                
                console.log('Mon Peer ID:', id);
            });

            peer.on('connection', async (connection) => {
                conn = connection;
                setupConnection();
                updateStatus('Connexion entrante...', false);
            });

            peer.on('error', (err) => {
                console.error('Erreur PeerJS:', err);
                alert('Erreur: ' + err.message);
                initBtn.disabled = false;
                initBtn.textContent = 'üöÄ Initialiser ma connexion';
            });
        }

        // Se connecter √† un peer
        async function connectToPeer() {
            const remotePeerId = document.getElementById('remotePeerId').value.trim().toLowerCase();
            
            if (!remotePeerId) {
                alert('Veuillez entrer un ID valide');
                return;
            }

            // V√©rifier la lettre de contr√¥le
            if (!verifyChecksum(remotePeerId)) {
                alert('‚ö†Ô∏è ID invalide : la lettre de contr√¥le ne correspond pas.\nV√©rifiez que vous avez correctement copi√© l\'ID.');
                return;
            }

            if (!peer) {
                alert('Veuillez d\'abord initialiser votre connexion');
                return;
            }

            updateStatus('Connexion en cours...', false);
            
            conn = peer.connect(remotePeerId, {
                reliable: true
            });
            
            setupConnection();
        }

        // Configuration de la connexion
        async function setupConnection() {
            conn.on('open', async () => {
                updateStatus('Connect√©', true);
                document.getElementById('connectionPanel').classList.add('hidden');
                document.getElementById('chatContainer').classList.add('active');
                document.getElementById('disconnectBtn').style.display = 'block';
                document.getElementById('encryptionBadge').style.display = 'inline-block';

                // Exporter et envoyer ma cl√© publique √† l'autre peer
                const myPublicKeyData = await exportPublicKey(myKeyPair.publicKey);
                conn.send({ type: 'public-key', data: myPublicKeyData });
                console.log('Cl√© publique ECDH envoy√©e');
                addSystemMessage('üîê √âchange de cl√©s en cours...');
            });

            conn.on('data', async (data) => {
                console.log('Donn√©es re√ßues:', data.type);
                
                if (data.type === 'public-key') {
                    // Recevoir la cl√© publique de l'autre peer
                    try {
                        otherPublicKey = await importPublicKey(data.data);
                        console.log('Cl√© publique de l\'autre peer re√ßue');
                        
                        // D√©river la cl√© partag√©e
                        encryptionKey = await deriveSharedKey(myKeyPair.privateKey, otherPublicKey);
                        console.log('Cl√© partag√©e d√©riv√©e avec ECDH P-384');
                        
                        addSystemMessage('üîê Connexion √©tablie et crypt√©e (ECDH P-384) !');
                        
                        // Envoyer confirmation
                        conn.send({ type: 'key-ready' });
                    } catch (e) {
                        console.error('Erreur √©change de cl√©s:', e);
                        addSystemMessage('‚ö†Ô∏è Erreur lors de l\'√©change de cl√©s');
                    }
                } else if (data.type === 'key-ready') {
                    // L'autre peer a termin√© le d√©rivation de cl√©
                    console.log('Confirmation: l\'autre peer est pr√™t');
                    addSystemMessage('üîê Connexion √©tablie et crypt√©e (ECDH P-384) !');
                } else if (data.type === 'message') {
                    // Attendre que la cl√© soit disponible
                    if (!encryptionKey) {
                        console.error('Cl√© de cryptage non disponible');
                        addMessage('[En attente de la cl√© de cryptage...]', 'received');
                        return;
                    }
                    
                    // D√©chiffrer et afficher le message
                    try {
                        console.log('Tentative de d√©cryptage du message...');
                        const decryptedMessage = await decryptMessage(data.data, encryptionKey);
                        console.log('Message d√©crypt√©:', decryptedMessage);
                        addMessage(decryptedMessage, 'received');
                    } catch (e) {
                        console.error('Erreur de d√©cryptage:', e);
                        addMessage('[Erreur de d√©cryptage]', 'received');
                    }
                }
            });

            conn.on('close', () => {
                updateStatus('D√©connect√©', false);
                addSystemMessage('‚ùå Connexion ferm√©e');
                resetChat();
            });

            conn.on('error', (err) => {
                console.error('Erreur de connexion:', err);
                addSystemMessage('‚ö†Ô∏è Erreur de connexion');
            });
        }

        // Envoyer un message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !conn) return;
            
            // V√©rifier que la cl√© est disponible
            if (!encryptionKey) {
                alert('‚ö†Ô∏è Cl√© de cryptage non disponible. Attendez la synchronisation...');
                return;
            }

            try {
                console.log('Cryptage du message:', message);
                const encryptedMessage = await encryptMessage(message, encryptionKey);
                console.log('Message crypt√©, envoi...');
                conn.send({ type: 'message', data: encryptedMessage });
                addMessage(message, 'sent');
                input.value = '';
            } catch (e) {
                console.error('Erreur d\'envoi:', e);
                addSystemMessage('‚ö†Ô∏è Erreur d\'envoi du message');
            }
        }

        // G√©rer la touche Entr√©e
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Ajouter un message √† l'interface
        function addMessage(text, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const now = new Date();
            const time = now.getHours().toString().padStart(2, '0') + ':' + 
                        now.getMinutes().toString().padStart(2, '0');
            
            messageDiv.innerHTML = `
                <div class="message-content">
                    ${escapeHtml(text)}
                    <div class="message-time">${time}</div>
                </div>
            `;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Ajouter un message syst√®me
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.style.textAlign = 'center';
            messageDiv.style.color = '#6c757d';
            messageDiv.style.fontSize = '14px';
            messageDiv.style.margin = '10px 0';
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // √âchapper le HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Mettre √† jour le statut
        function updateStatus(text, connected) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            if (connected) {
                indicator.classList.add('connected');
            } else {
                indicator.classList.remove('connected');
            }
        }

        // D√©connecter
        function disconnect() {
            if (conn) {
                conn.close();
            }
            if (peer) {
                peer.destroy();
            }
            resetChat();
            location.reload();
        }

        // R√©initialiser le chat
        function resetChat() {
            document.getElementById('connectionPanel').classList.remove('hidden');
            document.getElementById('chatContainer').classList.remove('active');
            document.getElementById('messages').innerHTML = '';
            document.getElementById('encryptionBadge').style.display = 'none';
            encryptionKey = null;
            myKeyPair = null;
            otherPublicKey = null;
        }

        // Enregistrer le Service Worker pour PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker enregistr√© avec succ√®s:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Erreur d\'enregistrement du Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
